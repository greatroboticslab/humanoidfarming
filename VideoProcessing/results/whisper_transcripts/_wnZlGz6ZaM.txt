Sling URIs and the new URI Mapping SPI
https://www.youtube.com/watch?v=_wnZlGz6ZaM
Science & Technology
 Okay, great. So I hope everyone can hear me. Interesting times, everything online. A shame to not be able to go to Berlin. I always enjoyed that. But on the other hand, like really great that the Adapt 2 team made it happen as a virtual conference. So I'm really glad to be here. My name is Georg Kanzler. I work for Netcentric. People might know Netcentric from the AEC tool, which we've developed a long time. It's also now actually available for IAM as a cloud service. Yes, I sit in Munich. And today I talk about sling worries and a new URI mapping SPI. So here we go. So worries when preparing this talk, I noticed, well, this is not the most exciting topic to talk about. It feels like really old fashioned. It almost feels like talking about core bar or web services, like something from the old days, vintage. So that's where this TV comes in. That TV is probably even like 20 years older. Also crazy. Like this ROC is from 1998. And that is old. That's more than 20 years. But on the other hand, like it's not even that old. Anyway, my point is, URIs are very important. And obviously, like sling being a web framework, it's very important to deal with you URIs. And I talk about this today. And it's not always easy, even though it probably should be easy. It is not always easy. Let's have a look. So I start with a few naive URI operations. And so how the following slides will work, you'll have like a bit of pseudo code, and you can think about what can go wrong. And then I show you an example of what goes wrong. So it's almost a bit of a game. Let's do it. Very simple pseudo code, what can go wrong. So you can imagine like a URL that will not like not work if you do it like that. And yes, I show you. Obviously, if there's already a fragment part in your URI, then this this will break. And there's more like that dangerous number two. We need to add a selector to to a link, we have already a link. And obviously, well, how am I gonna do it, I can just use string replace. And that's not the reg x variant. That's the variant that just works on strings and Java. And thus replace all of them. And obviously, what can go wrong? Well, if there's more than one dot HTML, like you might actually replace parts that you didn't want to replace dangerous number three, classic, make, make a relative URL, like add a host name to it, a base URL. So there's better ways, but I start with like a very simple one. So you just like prepend the base URL, if for example, if the link doesn't start with HTTP. So now, yeah, well, so if it's a mail to you, URI, then you might end up with something like this. Then obviously, you can write it slightly different. But this is still not safe, you might end with like something like this. So you know, these CDN links, which they work for HTTP and HTTPS contexts. And they also start with a slash, but they are not actually path absolute links. Now, yeah, obviously, we have an IEM, we have the externalizer. So we can use that tool to route through links and do it right, you could think, but there's also problems with that. So for example, if you if you pass in a mail to link here, then you get unexpected results. If you do the resource result of a map, you actually get like a non broken result. But the point of like this exercises, like the root cause of all this is because we are working on strings, and we probably shouldn't be working on strings. But why do we work on strings? Like, hopefully, like you all have never done these things that I just showed. But I've been looking at pull requests for 10 years. And I think sometimes you just come across these things. And like, you probably have experienced the same. And what is the reason? Well, yes, because like the sling API often uses strings for these type of things. So you have to pass in a string for resolve a map. And yeah, get path, obviously, it returns a path. And then we have the request path info, which is a great interface for interpreting incoming requests. So it's read only immutable, you can get the selectors and so on. Like mostly, it's actually used internally anyway, to for example, select the right scripts. Sometimes you use it in servlets to use some data from the request. So for the incoming part, it's good. But for the outgoing part, it's the problem is, there's no builder for it yet. But first, yeah, in general, let's talk about better you, you re handling. So we have HTL. So in HTL, we have and you can use Yeah, so you have the special parameters, you can add selectors, you can add the extension and all the problems that we've seen earlier, they just magically go away. The problem is, well, if you're not in HTL, or if you're maybe in an async process or workflow, or if you're generating JSON, well, then you don't have this so not that easy. Now, what else can we do? Obviously, standard Java has a Yuri class. And there is also if that's already a problem. So there is a Yuri available in aem a Yuri builder. But most people, many people don't know it. So it's part of the HTTP client. There's also one from Spring, which is not usually available, you would have to deploy the libraries. But yeah, so this works. What's the problem with that? Well, yeah, we don't have support for the sling specific Yuri parts on those electors, no suffix. So basically, we just have the path. And here comes in the sling Yuri builder, which is new. So basically, we have a sling Yuri, and we have a sling Yuri builder. And we can use like, if you compare those two, it's actually very similar for constructing a very easy URL. But yeah, the method names are the same. But you also have the ability to actually set the result path to sets selectors, extensions, like the things that we know from the request path info. And in the end, you just build it, and you have, again, an immutable instance of a sling Yuri. Now, the yes, this the sling Yuri also implements the request path info, which is really handy to use it in existing API's or in your existing code. So the the builder, what, what can you create it from? So obviously, from a string, which is the very last one. And that's a pass method, but you can create it from a request, which holds all this information, you can create it from a request path info, from a resource and from another sling Yuri, and from a regular Yuri from a Java Yuri. Now here, the resolver is marked. So the problem with the resource path is that sometimes the resource path contains a dot. So the typical case for this is that you have asset in a for example. So those have a resource path with a dot in it. And to find out if your Yuri, if like to correctly pass the resource path path, you need to you need to have a resolver to find out if the resource path contains the dot or not. Good. So and we also have like now obviously, this is immutable and that sling Yuri interface has a very handy default method to simply adjust an existing Yuri. So that's how it looks like. Now, so that was the first part. That was easy. That's very basic. And that's something new that you can use for the future. Now, the second part is introducing a link Yuri mapping SPI. And that is not finished yet. I thought like when I handed in the talk that maybe it would be but it's not yet. But it's still really an interesting topic to talk about. And to to get to first, let me stop sharing the screen and let's do let's use the means we have here to actually show you to have some pulse. So the first one I would like to do to answer you is how you use the resource resolver and one specific method. So I think you should be able to know to just quickly answer it. And we should see. Yeah. So I mean, we are 126 people. So I just give you the 1015 seconds to quickly answer this. And I see it comes it comes out in a way that I expected. So I think yeah, some more people some more people can maybe vote. That's good enough. I think we have a good we have a good picture of of what people feel about. So the answer is sometimes resource resolver sort of makes sense. Let's do the same for map. So again, I see there's a clear opinion about I know it's not actually a clear opinion. Very interesting to see that. How do it comes in? I think it's almost even. So almost even. Hey, we only have 50. I think there is like 70 people missing. They just have to click a few more. Okay, good. I think we have a good few of that. And then there's a last one. And I think most of you work in a m projects. So how do you map resources to absolute links today? Okay, which is always an interesting one. So custom service would usually also somehow use resolve a map or externalize it from my experience, but I've I've seen a lot of custom services in my in my life. So it probably also makes sense. So yeah, what I see is probably pretty much what I expected. So I can also close this part and go back to the slides. Because like these answers, they'll nicely support what I talk about. So the motivation for the sling you remapping SPI. So the goal is to have one concept for mapping your eyes and sling. And that should also work in a m. So it's it's a shame in a way that we have to use the externalizer in a way it would be good if resources or the map would just do everything that we need. And in a way it's prepared to do that. We have etc maps and you can have like absolute gurus created like that. But it just tends to be not really used that much because sometimes you hit some limitations around just using plain sling. So that's a goal to really have one concept that works forward. And with this one concept like if resources or if a map will really do the whole thing, that will enable us to actually use that in HTL. Because in HTL, we already have the URI context. We have or we know already what pieces in the rendering are or eyes and they can be mapped automatically without someone touching. So my point here is like people, a lot of people have said that they use resources of a map. And obviously you have to today. But the future best case is that you rarely have to use it or you only use it in workflows to actually map a URL for an email or something. And then after having done that, we can get rid of the output rewriting pipeline. So now the output rewriting pipeline is a nice and flexible way to rewrite complete HTML. Like you could put like an HTML fragment that is at the top to the bottom, which is obviously probably not good practice anyway, but you could do things like that. But really today it's mostly useful for link validation and actually mapping because in the end, the link checker performs the map. And in the future, that could look different. And that would make sense because it doesn't make sense to read the two parts and restream out like the whole HTML. So that's something for the future. And then there's a side goal that in the discussion that we started on the mailing list came out. The mapping as it stands today is after authentication. So that means you have already a resource resolver in your in your request. And the problem with that is if like for the authentication requirements that you declare, the mapping has not happened yet because the sling authenticator core does that before the mapping happens. So that means if you have sling alias and vanity URLs, you have to manually define authentication requirements. And that's something that came up in the discussion that we probably want to change that, which will mean a lot of changes and potentially a lot of breaking changes, which we want to avoid, obviously. So this is also one of the reasons why we're still working on invites not finished yet. Michael Hanna So now let's let's look at more details on how this can look like. So for the API, the goal is really to do not change the contract for existing code. So really the resources are resolved and map should stay. The idea is to have like an additional service path, the URI mapping service that allows to to do both operations map and resolve, but before the authentication and independent of the resource resolver, but the resource resolver would still provide the methods and actually delegate to the service. Maybe there's a it can make sense to have a flag for to force absolute URIs because at the moment that can be a problem with the ETC map implementation. And yes, and no and for this service, like no user contact should be available. And that's actually what it is today. So to see maps and sling areas vanity URLs, all that is not using the user authentication. Now for the SPI, so the whole point to so we need to be really flexible in the SPI to make sure that the HTL performing the map operation can do everything that potentially is needed. So that is URI mapping forward and reverse. The idea is for this SPI to have a chain of URI mappers, similar to what we have in the filter chain. And to do everything that is needed, you need to have access to the request, but also access to the resource resolver to check the existence of resources. And for the future, the idea is also to have like context hints. So for example, to be able to replace the link checker, to mark a link as link invalid, and then HDL can take care of it. Now let's do a quick, quick demo of what that can look like, because I don't have a lot of time left, but I just wanted to show you. So what they can look like. So basically you have a URI mapper service. And for this case, it's in that one is a simple method that just adds a HTML extension if it's missing. And it's you just implement the map. And you see if you have to check certain other things, but if there's no extension, then you can just set the extension. Or maybe this is the boring example, like something slightly different can look like this. So resolve and path extension is usually done in Apache. But this example that I just shown a second, like for the expansion, you make sure that you exclude certain paths that you don't want to map like this. And for the map part, you can basically, from a header, which is today not possible with etc maps. So etc maps would only respect the host header. But for a header, you could append this path. And then just a quick example of how this can look like. So basically, I'm not logged in. So at the moment, I have long URIs, but they are mapped already, you can see because I have a IAS here. So you see here in IAS. But now I can just add a request header. And like this is a custom request to the base path. And now just browsing this, you see it gets short. So this will just provide additional flexibility. So now I have to speed up because I think the time is almost over. Go back here. So conclusion, start using sling URI and sling URI builder. That's available from sling API to 2030. That was released last week. And for the sling URI map for SPI, you just got a quick overview on what's what's planned. We're on it. If you have feedback wishes, join in the discussion on dev sling Apache org. Because if you don't join in now on the dev list, then you'll have to ask later on the user list. So that's a good opportunity to join in now and provide feedback. So I think we don't have time for q&a. I stay a bit in the room so you can ask questions if you like. But overall, this is just like links around the whole discussion some cheater tickets. But other than that, thank you very much for your time. And yeah, that's it. Thank you. And bye bye.