Exceptions - Lesson 8 - Closing resources and dealing with resource leaks.try-with-resources
https://www.youtube.com/watch?v=V8UyBh-ZS1Q
Science & Technology
 Welcome to lesson 8 on exceptions. Closing resources and dealing with resource leaks. In this video we continue where we left off in lesson 7. What we'll do is we'll refactor our existing code. Then we'll look at simpler ways in closing our resources by making use of the try with resource statement that was introduced in Java 7. We'll also look at the rules when applying the try with resources. We'll discuss two very important interfaces with regards to try with resource statement, namely the java.lang.autoclosable and the java.io closable interfaces. I hope you enjoy this and don't forget to subscribe and so on. So let's get to it. Okay, carrying on from lesson 7. I want to show you something over here. If you look at this code here in test 2. I'm adding 2 to the counter. Wrongly thinking that when I write the line and I call new line first and then write the line. It's actually adding 2 lines and that's not so because the read line there. If you go and read what is the read line. It says here it reads a line of text. That is and the line is considered to be terminated when it finds a new line or carriage return and so on. But further it says the string containing the contents of the line does not include the line termination. So that's why the new line is added here because this will just be a long straight line of lines. It reads the line it sees when it's got a new line it will read the next line but it doesn't doesn't include the new line termination in it. And that's why I call a person has to call a new line here to add a termination. But in actual fact this would be 1. So the counter here should should be incremented by 1 every time. And then over here this multiplication is now because I just want to flush every thousand. OK. So if I go and save this and run it now. Let's see what happens. You see previously it flushed three times. And let's see what happens now. It's still flushing three times. OK. And then if I go and just refresh this. Let's see if my back file it is there. And there is no additional line. So just a fix on that. Remember that the read line reads a line and when it sees a line termination reads the next line. Reads the next line but all continuously. That's why on each line that is reading when I'm writing I'm adding a new line here. So this new line actually counts as one line. Otherwise it would be in a continuous line all the time. OK. So yeah. And then. Well I would have to do the same. With my test three. And just to show you I'm actually calling test two over here. Test three. I would also change this code here to just add one to the counter. And then I would take that one out. And if we test this. I'm just going to delete that over there. And then I will call test three instead of test two. So I'll comment that one out. Do that. Let's run it. We're using the ID. So what I actually wanted to see here is the refresh it. And there's Alice back. And that's working fine. Now looking at this code. You'll agree with me that the code to close the resources can still be quite complex because you've got to put it in your finally. And if you've got more than one resource you've got to guard against a null. And then catch that that exception. But make sure that you handle the closing of the next one irrespective of the previous one being thrown an exception or not. And now before I believe Java 8 this was the case. Now in Java 8 they introduced what they call try with resources. And I'm going to show you an example of this. And I'm going to use the same example. I'm going to call it test four. But I'm going to leave out the flush just to make it easier and more compact because we know and you guys won't. You can add the flush in the code yourself. You can go and download the code and just add it there. That will be a nice test for you. And this I wrote a little code test four where I'm using flush where I'm using close with resources. And if you look at this code. What's happened to my close? Where am I closing my resources? Okay. What's happening in this code? You'll see the tryer. I'm adding the Buffered Reader, my streams, my Buffered Reader and Buffered Writer inside brackets. You see, here's the bracket there and over there. So all my resources I initialize and I add inside this bracket when I, at the beginning of the try declaration. Where you will see the previous one didn't have that bracket. You see, I had to initialize it to null and then assign it on the inside of the bracket. This here is, there's no brackets and this one here I'm doing it inside. And then I'm just closing it and I'm throwing exception here because now in Java 8, they introduced a try with resources where. Okay. And take note any class that extends or not extends that implements. Sorry, the implements the auto closable interface. So the classes must implement the auto closable interface. Can then use try with resources. Now the close method is called automatically when it comes to the end. And the close method could throw an I exception and that's why I'm saying that I'm declaring to throw it here. Otherwise I would have to have a catch here. Now I just want to show you if I go to my Buffered Reader. And open it, you will see that the Buffered Reader, previously just the auto, the closable, but now it also implements the auto closable. Now the auto closable has got a close method. Okay. Just like the close, but this one is used with the close with resources and it was actually added as you can see in 1.7 Java 1.7, not 1.8 like I said earlier on. Okay, so 1.7 introduced the auto closable and you will see that the closable now it's subclasses the auto closable. It's subclasses. Let's just go to, there it is, closeable see. So you get, you get now closeable down here that implements, that extends auto closable. Okay. So, so now you don't have to worry about writing this code here in the finally box. It gets handled for you. And the main thing here is you have to put this try in brackets. You have to initialize and declare and initialize inside here. Otherwise you'll get a compiler error. And then you're basically I'm reading and writing. Yeah. I don't need to finalize it to check all of that. So let's see if I run this. So I'm calling it here. I'm just taking out the stats since I'm not implementing the, not using the flash, the flush, not the flush. Then try test four. So I'm calling test four and I'm catching the exception. Yeah. Now if it did throw an exception, so just going to delete this file. I'm sure that file must be unhappy or being deleted so many times already, but let's go. Okay. So I've got no errors. So let's just see if I refresh. There's my file. And there. Everything's working 100%. Okay. Let's look at, just revise the try catch finally that we had previously. Okay. And what you can see here, you got the try. Before the try, you would use in this, declare your, your resources you're going to use. Like your buffered read and writer and initialize them to null. Then you'd actually initialize them in the try block. And if anything happens, you'd catch a specific exceptions here. Then the finally used to wrap up critical things like closing your resources and so on. Now that's the try catch finally before Java seven. Now Java seven introduced the try with the resources. And yeah, I've got the sketch of what happened. So in your try, you know, in your try, you initialize your resource, you declared it and you initialize in your try. Try all your resources in a bracket. And then you would use it here. And when it closes here, you would then, it would then, when it comes here, it will call the auto-closable or the closable interface. Now note that this buffered reader and any resource that you're using has to implement the auto-closable interface or each subclass, the closable interface. Now you could, you can also have a catch or more than one catch and a finalier. But the close method is called implicitly irrespective of if the IO exception is called, an exception is called or the finally. So when it comes here, your close method of your closable or your auto-closable will be called. And we'll look at some of those examples. Okay. So let's test some of the rules or what we can do with the try with resources to do that. And I said to see how it works. Okay. So to do that, I've created a class, a very simple class called my resource. So I'm simulating a resource like a file, but it's just to see the mechanics. I'm just calling it my resource. And I've got a public void close method. And I'm printing out system out print line two. So if a close method gets called, two will be printed. Okay. Then I've got a method called test five. And yeah, I'm putting the try in, try with resources. And you can identify that because I've got my resources declared and initialized in, in the brain. In, in the bracket of the try. Now immediately you can see I've got a problem. Now it doesn't want to compile. And that's because if we highlight it there, you'll see it must implement the auto-closable interface. So it's telling me my resource is not a, doesn't implement the auto-closable interface. So let's just go and implement the auto-closable. Implements the auto-closable interface. And you see that error is gone. Now the auto-closable is got one method that you must override. And it's been overridden here. So if I misspelled it and I say closes, then you will see the, the close method hasn't been implemented though. Not part really of this, but it's always good to put an at override annotation. And that helps you identify that this method is not an override method because it's spelled wrong as well. So just going to fix it there. And you see it's all nice. Okay. So I'm calling test five over here. So what's happening is the, the compile error is no longer there. It's happy with my resource file. And in my resource file, it's going to print one. Now you see, I'm not calling close anyway. So what will happen if I call close, if I, if I run this, is it going to print one? Is it going to print what one and two? What's it going to do? Okay. So let's just run this. And I'm just going to run it quickly. And you see it printed one and it automatically called the close method of my resource class because it implements auto closable. I could also just implement it subclass, which is closable. And if I run it now, you'll see it compiles and it's fine. So it can be auto closable or a subclass. And we know closable is one of the subclasses. Okay. So as I mentioned before, as you can see here, I mentioned that even though the try with three sources cause the implicit finally, which is a cause the close method in the auto closable or closable, you can still add one or more catch blocks and a finally block. So let's test this out quickly and see how it works. Okay. So I modified or added a catch and I put the court exception IO exception E and in each block, I'm printing three. And in the finally I've added a finder as well. I'm printing four, but you'll see I also print one here. And then I call throw a new exception. So what happens? It will print one, then it will throw an exception. Well, that print three, four. What about when it reaches the other auto closable, the close method is called what will happen in this case? Because you'll see my auto closable prints two. Okay. In this case, the closable, which is a subclass of auto closable, a sub interface. Okay. So let's, let's go and look at that. Is it going to print one, three, four or one, three, four, two or one, three, two, four and so on. We can think of all the combinations, but what is the actual result? So, so let's go and run it quickly. And you'll see it printed one. So I printed this one. And when it came to the, it, it throws in a new X IO exception, but it, then it comes here. And before it executes the IO exception or a catch block before it executes a catch block, it goes and prints two. So it does the close method first, then it comes back and it does all the catch blocks and the finally block. Okay. What I've done in my resource class, I've added a public hello method. And if I call it, it will imprint my resource, which means I say hello in Portuguese. Okay. So let's go and look what happens if I use it. Okay. Yeah. I've called resource hello. And actually what I want to show you, if I take it and I to put it after the IO exception, the compiler would give an error because it's unreachable. Meaning that when, once an exception is thrown, it comes to this line, to the catch. So this could never happen because I'm on programmatically thrown exception there. So I'm going to move it back to where it was. And let's see what happens if I run it. And it prints one. The resource hello gets called. This method here gets called. It prints my resource, these all are. And then an exception is thrown, but the close method is called, which prints two, followed by the catch, which prints three and four. So that's working 100%. But what happened, what will happen if I also want to call this resource hello, say in the catch. And you see, I've got a compile error there. And if I put it in the finally, I've also got a compile error. The problem is that whatever you declare your resources, any resource that you declare that implements auto-closable or closable as we said, is bound, is scope bound. It's bound to this code here, that code there. So you cannot use it anywhere else. So in the same sense, you would not be able to call the resource close method anywhere else like this. That won't also work, although you could call it over here. Okay, then it would have called close twice there. So let's just take it out here. And I'm going to take it out over here. And call the close again. And you'll see in my example, the close was called there. And it was called again when it reached the thing. But what's important to note here is that your variable, your reference variable of your resource is scope bound to your try. So you wouldn't use it anywhere else outside it. Now, if you look at this, we've called close here. And we know that it's implicitly called here as well when it reaches the end. And that's why it's printed two twice. But it just does not make sense. Why would we try and close something twice? Why would we call close twice? Okay. So the close method in closable, one of its properties is that it is required to be idempotent. Meaning that once you've called the close once, it shouldn't, if you call it again, it should have no effect on it. It shouldn't try and close it again. Now, let's try and do that with our class over here. So I'm going to change the code so that to try and make it idempotent. And you'll see what I've done is in my no argument construct, and I'm sure there's many other ways of doing this. I've assigned the object that's created this to my, to the variable resource. So I'm keeping track of the resource that was created, the object in other words. And then in my close, I test first to see if the resource is null. If it's null, then I just return. If it's not null, I would close, which I'm going to print to you so we can see what happens. If I run this, if you can see I had one, two, two, three, four. And that two, two comes because I'm calling close here. And then when it reaches here, it tries and closes my resource again. So let's run it. And you see now, even though I'm calling close here and I'm calling close there, I'm actually only closing it once. The next time it comes here, it would see that it's null and it just returns. Okay. If we go and look at the implementation class, let's say buffered reader. And we go and look, you see they've also got a reference variable of reader and it defaulted to null. If you don't give it anything, it's null because it's an object. And if I go and look at the close method implementation, you'll see, okay, apart from it being synchronized and it's throwing IO exception, you'll see it checks if it's null. If it's null, it will return. Otherwise, it will call the reader's close. Okay. And then it's got to finally, if it crashes, it will make it null. So that is idempotent. Now, what will happen if my resources that implements closeable or auto-closable, in this case, closeable, what will happen if, say, I declare to throw a checked exception here? Okay. I'm going to leave this class as it is so that you guys got it. But I'm going to have another class here called another resource. And I'm implementing closeable. And, and I didn't over, I left the IO exception, throws I exception. So I'm declaring that I throw an IO exception. And then I'm actually going to throw a new IO exception error when trying to close. Now, what will happen if I use this in a try with resources? Remember that the close is called automatically. But now I'm throwing exception. What will happen? Okay. So, yeah, in test six, I've declared a resource, another, and it's going to close. And it's going to call close, the close method, yeah, that's going to throw a caught exception. And remember, excuse me, the caught exception has to be caught or handled, declared or handled. So it's giving me a compiler error. So I have to, when, when my close method throws an exception, I have to handle it. So I could either declare to throw it out to the client. Or in this case, I'm going to put it in a catch. And I'm going to say it's an IO exception. So I'm going to catch a specific, the most specific exception in this case, which is IO exception. And I'm going to say, I'm just going to print the message. System.out.println.zee.getMessage. Okay. So let's see now. Now it's not complaining anymore. And what happens if I now run it, I'm going to compile it and run it. And let's see an error when trying to close. So the message, the, you see the message of the exception, this one here. So I threw the exception and I caught it here. And then I printed the message. So if your close method is going to throw a caught or a checked exception, in other words. Then I have to handle it or declare it. I could have said, yeah, throws an IO exception and have it handled in the main method. Okay. Also take note that the finally would be executed irrespective. But note that if I just use a finally, I've still got a problem. Now remember the finally doesn't catch your exceptions. It's to do anything after whatever you've done. So the finally one solved my problem. I still have to put a catch here to catch this exception that's been declared to be thrown here. And it is actually throwing one. Okay. Now let's look at another situation. Say there's more than one exception thrown. Like in this case here, in another resource in the try block, I'm throwing an IO exception. The exception exception in try block. And then the end of this, the close method will be caught of another resource. And you'll see the close method of another resource, osathrose, an IO exception. Which one will be caught here in printed? Let's have a look at this. Exception in try block. So the rule says if more than one exception is thrown, the main exception will be the one that will be caught. The first exception in other words is known as the main exception. Or the primary exception will be caught. Okay. Let's look at this example. Yeah. I've got a class called Karu. Which stands for car. And it implements auto-closable. And I've got a string named Tipu. Means type. And then in the Karu, in the constructor, I will then initialize whatever passed this type of the car. And then it's got a close method. Under the close method, it will throw an exception. And the message will be the type of the vehicle. Lansou uma exceção. Which means it threw an exception. So if it's a, say a Peugeot, it will say Peugeot through an exception. Lansou uma exceção. Okay. So what will happen in the case which I've got here in test seven. What I've done here is I've actually got two instances of this Karu class. So creating two instances, which is in a try with resources. And then I'm going to catch it. Which one of the two will be caught? Remember, we know that the primary one will be caught. Because there's more than one. But which one of the two will be caught? Okay. Let's have a look at that. And you see that this, the last one. In this case, the second one. But another rule is that when at the close, it closes the resources in reverse order. The last one gets closed first and then the next one and so on. And since the last one was the first one to close, it becomes the principal or the primary exception. And that's why it's printed there. Okay. Okay. So all that I did here on this seven for now. I've added. I've thrown a new exception here. You know, so on Karu is the message. I am not a motor car. I am not a motor car. In the try block of the try with resources. So this logically would be the primary exception. Then the other two would be thrown. So I should just see, you know, so on Karu. So let's just see what happens if it works. And yes, it's working fine. But now what happened to the other exceptions because only the primary is thrown. Now before Java seven when the try with resources, you only had access to the one. But now what with Java seven, you can actually get the other exceptions. They are suppressed exceptions. They've been suppressed. So you can just. Yeah, I've just put in the code so I can now go and get all my other suppressed exceptions that have also been thrown. So let's see what happens. Yeah, we know it's in the reverse order. We know this one is in the principle in this case because they are. I'm playing this one first before the close is reached and we know it's in reverse order. So I should see now. He'll know so. Karu followed by the message. The last one. P Joe, the so he says so. Then Alfa Romeo, the so he says so. Okay. And yeah, you'll see the code. I put it in a for loop and the get suppression returns. As you can see, an array of type throwable, which is a super class of all exceptions. And this is a method to get them get suppressed. So if I'm going to run it. Then I'm using the throwable to print out the message over there. So I'm going to run it. And there it is. The main message was. Was thrown first and caught. And the other two suppressed exceptions in reverse order. In other words, the last resource is closed first. And then the second last to the last. So first and so on. So we've dealt with in the try with resources statement. In a try catch finally statement, you must have at least one or more catch blocks. And or a finally block. It means that you could have a catch block or a finally block or both. With a try with resources, this is still true. You just don't have to type it. The finally is implicit. You may still add one or more catch blocks and or a finally block. Even if you add a catch or finally, the close method is still called automatically. The resources created in the try clause are only in scope within the try block. You can't just put a random clause in the try with resource statement. Remember when it needs to implement the auto-closable. The closable required is implemented to be. In other words, closable is required to be. In the potent. The implementation of the closable. If a resource declares to throw a checked exception, this you must. Handle or declare it. If more than one exception is thrown, then the primary exception is thrown. The other exceptions are suppressed. Resources are closed in reverse order. There are parks and those sources on & cutses. Are you Harold, are you all, are you? Are you all, are you? I'm sorry, girl. I'm sorry, girl. Are you? Are you all trails? I know you're. Can you find out. I'm sure you guys need a well relaxing break go and watch that and don't forget to subscribe to my channel by pressing the subscribe button. Like if you liked it, comments and so on. And I've also got a Facebook page related to this channel. So check that one out as well. Thank you and I'll see you in the next lesson. Thank you.